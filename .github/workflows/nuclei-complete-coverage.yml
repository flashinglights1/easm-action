name: Nuclei Complete Coverage Scanner

on:
  workflow_dispatch:
    inputs:
      scan_profile:
        description: 'Scan profile to use'
        required: true
        default: 'quick'
        type: choice
        options:
        - 'ultra-fast'
        - 'quick'
        - 'critical'
        - 'full'
      max_parallel_jobs:
        description: 'Maximum parallel scanning jobs'
        required: false
        default: '10'
        type: string
      delay_between_batches:
        description: 'Delay between batch triggers (minutes)'
        required: false
        default: '2'
        type: string
env:
  RESULTS_BRANCH: "scan-results"
  GPG_KEY_ID: ${{ secrets.GPG_KEY_ID }}

jobs:
  calculate-total-coverage:
    runs-on: ubuntu-latest
    outputs:
      total_batches: ${{ steps.calculate.outputs.total_batches }}
      batch_size: ${{ steps.calculate.outputs.batch_size }}
      total_subdomains: ${{ steps.calculate.outputs.total_subdomains }}
      scan_matrix: ${{ steps.calculate.outputs.scan_matrix }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup GPG for decryption
        run: |
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --batch --import
          gpg --list-secret-keys --keyid-format LONG

      - name: Decrypt and analyze subdomains
        id: calculate
        run: |
          # Decrypt the subdomain file
          if [ -f "subdomains/all-subdomains.txt.gpg" ]; then
            gpg --batch --yes --trust-model always \
              --decrypt "subdomains/all-subdomains.txt.gpg" > temp_subdomains.txt
            
            TOTAL_SUBDOMAINS=$(wc -l < temp_subdomains.txt)
            echo "ðŸ“Š Total subdomains found: $TOTAL_SUBDOMAINS"
          else
            echo "âŒ Encrypted subdomain file not found!"
            exit 1
          fi
          
          # Get batch size from mass-scan workflow
          BATCH_SIZE=$(grep "BATCH_SIZE:" .github/workflows/nuclei-mass-scan.yml | head -1 | sed 's/.*BATCH_SIZE: *\([0-9]*\).*/\1/')
          echo "ðŸ“¦ Detected batch size: $BATCH_SIZE"
          
          # Calculate total batches needed
          TOTAL_BATCHES=$(( (TOTAL_SUBDOMAINS + BATCH_SIZE - 1) / BATCH_SIZE ))
          echo "ðŸŽ¯ Total batches required: $TOTAL_BATCHES"
          
          # Create scan matrix for parallel processing
          MAX_PARALLEL=${{ github.event.inputs.max_parallel_jobs || '10' }}
          
          # Generate batch numbers array
          BATCH_ARRAY="["
          for i in $(seq 1 $TOTAL_BATCHES); do
            if [ $i -eq $TOTAL_BATCHES ]; then
              BATCH_ARRAY="${BATCH_ARRAY}$i"
            else
              BATCH_ARRAY="${BATCH_ARRAY}$i,"
            fi
          done
          BATCH_ARRAY="${BATCH_ARRAY}]"
          
          echo "total_batches=$TOTAL_BATCHES" >> $GITHUB_OUTPUT
          echo "batch_size=$BATCH_SIZE" >> $GITHUB_OUTPUT
          echo "total_subdomains=$TOTAL_SUBDOMAINS" >> $GITHUB_OUTPUT
          echo "scan_matrix=$BATCH_ARRAY" >> $GITHUB_OUTPUT
          
          # Clean up
          rm -f temp_subdomains.txt
          
          echo "âœ… Coverage calculation complete!"
          echo "ðŸ“ˆ Will scan $TOTAL_SUBDOMAINS subdomains in $TOTAL_BATCHES batches of $BATCH_SIZE each"

  create-batch-groups:
    needs: calculate-total-coverage
    runs-on: ubuntu-latest
    outputs:
      batch_groups: ${{ steps.create-groups.outputs.batch_groups }}
      total_groups: ${{ steps.create-groups.outputs.total_groups }}
    steps:
      - name: Create batch groups to stay within GitHub limits
        id: create-groups
        run: |
          TOTAL_BATCHES=${{ needs.calculate-total-coverage.outputs.total_batches }}
          MAX_BATCHES_PER_GROUP=200  # Stay well under 256 limit
          
          # Calculate number of groups needed
          TOTAL_GROUPS=$(( (TOTAL_BATCHES + MAX_BATCHES_PER_GROUP - 1) / MAX_BATCHES_PER_GROUP ))
          
          echo "ðŸ“Š Creating $TOTAL_GROUPS groups for $TOTAL_BATCHES batches"
          
          # Create groups array
          GROUPS_ARRAY="["
          for group in $(seq 1 $TOTAL_GROUPS); do
            if [ $group -eq $TOTAL_GROUPS ]; then
              GROUPS_ARRAY="${GROUPS_ARRAY}$group"
            else
              GROUPS_ARRAY="${GROUPS_ARRAY}$group,"
            fi
          done
          GROUPS_ARRAY="${GROUPS_ARRAY}]"
          
          echo "batch_groups=$GROUPS_ARRAY" >> $GITHUB_OUTPUT
          echo "total_groups=$TOTAL_GROUPS" >> $GITHUB_OUTPUT
          
          echo "âœ… Created $TOTAL_GROUPS batch groups"

  trigger-batch-groups:
    needs: [calculate-total-coverage, create-batch-groups]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      max-parallel: 3  # Process 3 groups at a time
      matrix:
        group_number: ${{ fromJson(needs.create-batch-groups.outputs.batch_groups) }}
    steps:
      - name: Calculate batch range for this group
        id: calc-range
        run: |
          GROUP_NUM=${{ matrix.group_number }}
          TOTAL_BATCHES=${{ needs.calculate-total-coverage.outputs.total_batches }}
          MAX_BATCHES_PER_GROUP=200
          
          # Calculate start and end batch for this group
          BATCH_START=$(( (GROUP_NUM - 1) * MAX_BATCHES_PER_GROUP + 1 ))
          BATCH_END=$(( GROUP_NUM * MAX_BATCHES_PER_GROUP ))
          
          # Don't exceed total batches
          if [ $BATCH_END -gt $TOTAL_BATCHES ]; then
            BATCH_END=$TOTAL_BATCHES
          fi
          
          echo "group_batch_start=$BATCH_START" >> $GITHUB_OUTPUT
          echo "group_batch_end=$BATCH_END" >> $GITHUB_OUTPUT
          
          echo "ðŸŽ¯ Group $GROUP_NUM will process batches $BATCH_START to $BATCH_END"

      - name: Trigger mass scan for batch range
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const groupNum = ${{ matrix.group_number }};
            const batchStart = ${{ steps.calc-range.outputs.group_batch_start }};
            const batchEnd = ${{ steps.calc-range.outputs.group_batch_end }};
            const scanProfile = '${{ github.event.inputs.scan_profile || 'quick' }}';
            const batchSize = '${{ needs.calculate-total-coverage.outputs.batch_size }}';
            const delayMinutes = parseInt('${{ github.event.inputs.delay_between_batches || '2' }}');
            
            console.log(`ðŸŽ¯ Group ${groupNum}: Processing batches ${batchStart} to ${batchEnd}`);
            
            let successCount = 0;
            let errorCount = 0;
            
            // Process each batch in this group
            for (let batchNum = batchStart; batchNum <= batchEnd; batchNum++) {
              try {
                console.log(`ðŸš€ Triggering batch ${batchNum}...`);
                
                const response = await github.rest.actions.createWorkflowDispatch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: 'nuclei-mass-scan.yml',
                  ref: 'main',
                  inputs: {
                    batch_start: batchNum.toString(),
                    batch_end: batchNum.toString(),
                    batch_size: batchSize,
                    scan_profile: scanProfile
                  }
                });
                
                successCount++;
                console.log(`âœ… Successfully triggered batch ${batchNum}`);
                
                // Add delay between triggers to avoid rate limiting
                if (batchNum < batchEnd) {
                  console.log(`â±ï¸ Waiting ${delayMinutes} minutes before next batch...`);
                  await new Promise(resolve => setTimeout(resolve, delayMinutes * 60 * 1000));
                }
                
              } catch (error) {
                errorCount++;
                console.error(`âŒ Failed to trigger batch ${batchNum}:`, error.message);
                // Continue with next batch even if one fails
              }
            }
            
            console.log(`ðŸ“Š Group ${groupNum} Summary:`);
            console.log(`âœ… Successful triggers: ${successCount}`);
            console.log(`âŒ Failed triggers: ${errorCount}`);
            console.log(`ðŸ“ˆ Total batches processed: ${batchEnd - batchStart + 1}`);
            
            if (errorCount > 0) {
              console.log(`âš ï¸ Some batches failed to trigger. Check logs above for details.`);
            }

  monitor-completion:
    needs: [calculate-total-coverage, create-batch-groups, trigger-batch-groups]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Generate completion report
        run: |
          echo "# ðŸŽ¯ Complete Coverage Scan Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸ“Š Scan Overview" >> $GITHUB_STEP_SUMMARY
          echo "- **Total Subdomains**: ${{ needs.calculate-total-coverage.outputs.total_subdomains }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Batch Size**: ${{ needs.calculate-total-coverage.outputs.batch_size }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Total Batches**: ${{ needs.calculate-total-coverage.outputs.total_batches }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Total Groups**: ${{ needs.create-batch-groups.outputs.total_groups }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Scan Profile**: ${{ github.event.inputs.scan_profile || 'quick' }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Batches per Group**: 200" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸš€ Batch Trigger Status" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.trigger-batch-groups.result }}" = "success" ]; then
            echo "âœ… **All batch groups processed successfully!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ” **Next Steps:**" >> $GITHUB_STEP_SUMMARY
            echo "1. Monitor individual batch workflows in the Actions tab" >> $GITHUB_STEP_SUMMARY
            echo "2. Results will be stored encrypted in the \`${{ env.RESULTS_BRANCH }}\` branch" >> $GITHUB_STEP_SUMMARY
            echo "3. Use \`scripts/decrypt-results.sh\` to view results locally" >> $GITHUB_STEP_SUMMARY
          else
            echo "âš ï¸ **Some batch groups may have failed**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Check the trigger-batch-groups job logs for details." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸ“ˆ Coverage Guarantee" >> $GITHUB_STEP_SUMMARY
          echo "This workflow ensures **100% coverage** of all subdomains by:" >> $GITHUB_STEP_SUMMARY
          echo "- Calculating exact batch count needed" >> $GITHUB_STEP_SUMMARY
          echo "- Grouping batches to stay within GitHub limits (200 batches per group)" >> $GITHUB_STEP_SUMMARY
          echo "- Triggering individual scans for each batch" >> $GITHUB_STEP_SUMMARY
          echo "- Using the same batch size as configured in mass-scan workflow" >> $GITHUB_STEP_SUMMARY
          echo "- No subdomain is skipped or scanned twice per run" >> $GITHUB_STEP_SUMMARY

      - name: Create tracking issue (if enabled)
        if: github.event.inputs.scan_profile == 'full'
        uses: actions/github-script@v7
        with:
          script: |
            const title = `Complete Coverage Scan - ${new Date().toISOString().split('T')[0]}`;
            const body = `# Complete Coverage Scan Report
            
            **Started**: ${new Date().toISOString()}
            **Total Subdomains**: ${{ needs.calculate-total-coverage.outputs.total_subdomains }}
            **Total Batches**: ${{ needs.calculate-total-coverage.outputs.total_batches }}
            **Batch Size**: ${{ needs.calculate-total-coverage.outputs.batch_size }}
            **Scan Profile**: ${{ github.event.inputs.scan_profile || 'quick' }}
            
            ## Progress Tracking
            - [ ] All batches triggered
            - [ ] All scans completed
            - [ ] Results consolidated
            - [ ] Analysis complete
            
            **Workflow Run**: [View Details](${context.payload.repository.html_url}/actions/runs/${context.runId})
            `;
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['nuclei-scan', 'complete-coverage']
            });

